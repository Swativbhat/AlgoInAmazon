<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Case Study-7</title>
    <link rel="icon" href="../images/icon.png" type="image/png" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"
    />

    <style>
      /*  import google fonts */
      @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Ubuntu:wght@400;500;700&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        text-decoration: none;
        scroll-behavior: smooth;
      }
      body {
        font-family: "Poppins", sans-serif;
        margin: 0;
        padding: 0;
        background-color: #121212;
        color: #fff;
      }

      /* navbar styling  */
      .navbar {
        position: fixed;
        width: 100%;
        z-index: 999;
        padding: 30px 0;
        font-family: "Ubuntu", sans-serif;
        transition: all 0.3s ease;
        background-color: rgba(18, 18, 18, 0.9);
        backdrop-filter: blur(10px);
        /* margin-left: 100px; */
      }

      .navbar.sticky {
        padding: 15px 0;
        background: rgba(30, 30, 30, 0.95);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      }

      .navbar .max-width {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 50px;
      }

      .navbar .logo a {
        color: #fff;
        font-size: 35px;
        font-weight: 600;
        letter-spacing: 1px;
        margin-left: 150px;
      }

      .navbar .logo a span {
        color: #bb86fc;
        transition: all 0.3s ease;
      }

      .navbar.sticky .logo a span {
        color: #bb86fc;
      }

      .navbar .menu li {
        list-style: none;
        display: inline-block;
      }

      .navbar .menu li a {
        display: block;
        color: #e0e0e0;
        font-size: 18px;
        font-weight: 500;
        margin-left: 25px;
        transition: color 0.3s ease;
        position: relative;
      }

      .navbar .menu li a:hover {
        color: #bb86fc;
      }

      .navbar .menu li a::after {
        content: "";
        position: absolute;
        width: 0;
        height: 2px;
        background: #bb86fc;
        bottom: -5px;
        left: 0;
        transition: width 0.3s ease;
      }

      .navbar .menu li a:hover::after {
        width: 100%;
      }

      .navbar.sticky .menu li a:hover {
        color: #bb86fc;
      }
      .case-study-container {
        max-width: 900px;
        margin: 0 auto 60px auto;
        padding: 160px 20px 0 20px; /* Top padding accounts for fixed navbar height */
      }

      .case-study-title {
        font-size: 32px;
        color: #bb86fc;
        margin-bottom: 20px;
        font-family: "Ubuntu", sans-serif;
        /* margin-left: 150px; */
      }
      .case-study-title-2 {
        font-size: 32px;
        color: #bb86fc;
        margin-bottom: 20px;
        font-family: "Ubuntu", sans-serif;
        margin-top: 100px;
      }
      .case-study-image {
        width: 100%;
        border-radius: 12px;
        margin-bottom: 30px;
      }

      .case-study-text {
        font-size: 18px;
        line-height: 1.8;
        color: #e0e0e0;
        margin-bottom: 25px;
      }

      .code-block {
        background-color: #1e1e1e;
        color: #d4d4d4;
        padding: 20px;
        border-radius: 10px;
        overflow-x: auto;
        font-family: monospace;
        font-size: 15px;
        margin-bottom: 30px;
      }

      .case-study-navigation {
        display: flex;
        justify-content: space-between;
        margin-bottom: 40px;
        margin-top: 40px;
      }

      .nav-link {
        color: #bb86fc;
        font-weight: 500;
        transition: color 0.3s ease;
      }

      .nav-link:hover {
        color: #ffffff;
      }

      .references {
        margin-top: 40px;
      }

      .reference-title {
        font-size: 20px;
        color: #bb86fc;
        margin-bottom: 10px;
      }

      .reference-list {
        list-style: disc;
        padding-left: 20px;
        color: #e0e0e0;
      }

      .reference-link {
        color: #bb86fc;
        text-decoration: underline;
      }

      .reference-link:hover {
        color: #ffffff;
      }
      .complexity-card {
        background-color: #1e1e1e;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 30px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      }

      .card-title {
        font-size: 20px;
        color: #bb86fc;
        margin-bottom: 15px;
      }

      .complexity-table {
        width: 100%;
        border-collapse: collapse;
        color: #e0e0e0;
        font-size: 16px;
      }

      .complexity-table th,
      .complexity-table td {
        padding: 12px 15px;
        border: 1px solid #444;
        text-align: left;
      }

      .complexity-table th {
        background-color: #2a2a2a;
        color: #ffffff;
      }

      .complexity-table tr:nth-child(even) {
        background-color: #2e2e2e;
      }
      .quote-card {
        background-color: #1e1e1e;
        border-left: 5px solid #bb86fc;
        padding: 25px 30px;
        margin: 60px auto;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        max-width: 800px;
        text-align: center;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .quote-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 6px 25px rgba(187, 134, 252, 0.3);
      }

      .quote-text {
        font-size: 22px;
        font-style: italic;
        color: #e0e0e0;
        line-height: 1.7;
        position: relative;
      }

      .quote-text i {
        color: #bb86fc;
        font-size: 20px;
        margin-right: 10px;
      }

      .quote-author {
        font-size: 16px;
        color: #bb86fc;
        font-weight: 500;
        margin-top: 15px;
      }
    </style>
  </head>
  <body>
    <nav class="navbar">
      <div class="max-width">
        <div class="logo">
          <a href="#"><span>AlgoInAmazon</span></a>
        </div>
        <ul class="menu">
          <li><a href="../index.html" class="menu-btn">Home</a></li>
          <li>
            <a href="../domain/#case-studies-section" class="menu-btn"
              >Case studies</a
            >
          </li>
         <li><a href="../index.html#contact" class="menu-btn">Details</a></li>
        </ul>
        <div class="menu-btn">
          <i class="fas fa-bars"></i>
        </div>
      </div>
    </nav>

    <section id="case-studies-section" class="case-study-container">
      <h2 class="case-study-title">
        <i class="fas fa-briefcase"></i>
        Product Searches and Ranking
      </h2>

      <h2 class="case-study-title">
        <i class="fas fa-check-circle"></i> 1.Radix Tree
      </h2>
      Radix trees can be used to quickly find products by matching word
      prefixes, making searches faster and using less memory than regular trees.
      This helps show relevant results faster, improving user experience and
      saving system resources.

      <p class="case-study-text"></p>
      <img
        src="../images/case-7.jpg"
        alt="Case study visual"
        class="case-study-image"
        height="450px"
      />

      <h2>Code:</h2>
      <pre class="code-block"><code> 
         #include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

class RadixNode {
public:
    std::unordered_map&lt;char, RadixNode*&gt; nodes;
    bool is_leaf;
    std::string prefix;

    RadixNode(const std::string&amp; prefix = &quot;&quot;, bool is_leaf = false)
        : prefix(prefix), is_leaf(is_leaf) {}

    std::tuple&lt;std::string, std::string, std::string&gt; match(const std::string&amp; word) {
        size_t x = 0;
        for (size_t i = 0; i &lt; std::min(prefix.size(), word.size()); ++i) {
            if (prefix[i] != word[i]) break;
            ++x;
        }
        return { prefix.substr(0, x), prefix.substr(x), word.substr(x) };
    }

    void insert_many(const std::vector&lt;std::string&gt;& words) {
        for (const auto&amp; word : words) {
            insert(word);
        }
    }

    void insert(const std::string&amp; word) {
        if (prefix == word && !is_leaf) {
            is_leaf = true;
            return;
        }
        if (nodes.find(word[0]) == nodes.end()) {
            nodes[word[0]] = new RadixNode(word, true);
        } else {
            auto incoming_node = nodes[word[0]];
            std::string matching_string, remaining_prefix, remaining_word;
            std::tie(matching_string, remaining_prefix, remaining_word) = incoming_node-&gt;match(word);

            if (remaining_prefix.empty()) {
                incoming_node-&gt;insert(remaining_word);
            } else {
                incoming_node-&gt;prefix = remaining_prefix;
                auto aux_node = nodes[matching_string[0]];
                nodes[matching_string[0]] = new RadixNode(matching_string, false);
                nodes[matching_string[0]]-&gt;nodes[remaining_prefix[0]] = aux_node;

                if (remaining_word.empty()) {
                    nodes[matching_string[0]]-&gt;is_leaf = true;
                } else {
                    nodes[matching_string[0]]-&gt;insert(remaining_word);
                }
            }
        }
    }

    bool find(const std::string&amp; word) {
        auto it = nodes.find(word[0]);
        if (it == nodes.end()) return false;
        auto incoming_node = it-&gt;second;
        std::string matching_string, remaining_prefix, remaining_word;
        std::tie(matching_string, remaining_prefix, remaining_word) = incoming_node-&gt;match(word);

        if (!remaining_prefix.empty()) return false;
        if (remaining_word.empty()) return incoming_node-&gt;is_leaf;
        return incoming_node-&gt;find(remaining_word);
    }

    bool delete_word(const std::string&amp; word) {
        auto it = nodes.find(word[0]);
        if (it == nodes.end()) return false;
        auto incoming_node = it-&gt;second;
        std::string matching_string, remaining_prefix, remaining_word;
        std::tie(matching_string, remaining_prefix, remaining_word) = incoming_node-&gt;match(word);

        if (!remaining_prefix.empty()) return false;
        if (!remaining_word.empty()) return incoming_node-&gt;delete_word(remaining_word);
        if (!incoming_node-&gt;is_leaf) return false;

        if (incoming_node-&gt;nodes.empty()) {
            delete nodes[word[0]];
            nodes.erase(word[0]);
            if (nodes.size() == 1 && !is_leaf) {
                auto merging_node = nodes.begin()-&gt;second;
                is_leaf = merging_node-&gt;is_leaf;
                prefix += merging_node-&gt;prefix;
                nodes = merging_node-&gt;nodes;
                delete merging_node;
            }
        } else if (incoming_node-&gt;nodes.size() &gt; 1) {
            incoming_node-&gt;is_leaf = false;
        } else {
            auto merging_node = incoming_node-&gt;nodes.begin()-&gt;second;
            incoming_node-&gt;is_leaf = merging_node-&gt;is_leaf;
            incoming_node-&gt;prefix += merging_node-&gt;prefix;
            incoming_node-&gt;nodes = merging_node-&gt;nodes;
            delete merging_node;
        }
        return true;
    }
};

void test_trie() {
    std::vector&lt;std::string&gt; words = { &quot;banana&quot;, &quot;bananas&quot;, &quot;bandana&quot;, &quot;band&quot;, &quot;apple&quot;, &quot;all&quot;, &quot;beast&quot; };
    RadixNode root;
    root.insert_many(words);

    for (const auto&amp; word : words) {
        if (!root.find(word)) {
            std::cout &lt;&lt; &quot;Test failed: word not found - &quot; &lt;&lt; word &lt;&lt; std::endl;
            return;
        }
    }

    if (root.find(&quot;bandanas&quot;) || root.find(&quot;apps&quot;)) {
        std::cout &lt;&lt; &quot;Test failed: unexpected word found.&quot; &lt;&lt; std::endl;
        return;
    }

    root.delete_word(&quot;all&quot;);
    if (root.find(&quot;all&quot;)) {
        std::cout &lt;&lt; &quot;Test failed: word found after deletion - all&quot; &lt;&lt; std::endl;
        return;
    }

    root.delete_word(&quot;banana&quot;);
    if (root.find(&quot;banana&quot;)) {
        std::cout &lt;&lt; &quot;Test failed: word found after deletion - banana&quot; &lt;&lt; std::endl;
        return;
    }

    if (!root.find(&quot;bananas&quot;)) {
        std::cout &lt;&lt; &quot;Test failed: word not found - bananas&quot; &lt;&lt; std::endl;
        return;
    }

    std::cout &lt;&lt; &quot;All tests passed.&quot; &lt;&lt; std::endl;
}

int main() {
    test_trie();
    return 0;
}
  </code></pre>
      <div class="complexity-card">
        <h3 class="card-title">Time Complexity</h3>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Insertion</td>
              <td>O(k)</td>
            </tr>
            <tr>
              <td>Deletion</td>
              <td>O(k)</td>
            </tr>
            <tr>
              <td>Search</td>
              <td>O(k)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="complexity-card">
        <h3 class="card-title">Space Complexity</h3>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Operation</th>
              <th>Complexity</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Insertion</td>
              <td>O(n * k)</td>
            </tr>
            <tr>
              <td>Deletion</td>
              <td>O(1)</td>
            </tr>
            <tr>
              <td>Search</td>
              <td>O(1)</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="references">
        <h4 class="reference-title">Note</h4>
        <ul class="reference-list">
          <li>k is the length of the keys</li>
          <li>n is the number of keys</li>
        </ul>
      </div>

      <div class="references">
        <h3 class="reference-title">References</h3>
        <ul class="reference-list">
          <li>
            <a
              href="https://en.wikipedia.org/wiki/Radix_tree"
              target="_blank"
              class="reference-link"
              >https://en.wikipedia.org/wiki/Radix_tree</a
            >
          </li>
          <li>
            <a
              href="https://medium.com/basecs/compressing-radix-trees-without-too-many-tears-a2e658adb9a0"
              target="_blank"
              class="reference-link"
              >https://medium.com/basecs/compressing-radix-trees-without-too-many-tears-a2e658adb9a0</a
            >
          </li>
        </ul>
      </div>

      <h2 class="case-study-title-2">
        <i class="fas fa-check-circle"></i> 2.AVL trees
      </h2>

      <p class="case-study-text">
        AVL trees can be used in product ranking by keeping products sorted
        based on their relevance or popularity scores. This allows quick
        retrieval of the most relevant items for display while ensuring balanced
        search performance.
      </p>
      <img
        src="https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif"
        alt="AVL Tree Animation"
        class="case-study-image"
        height="350px"
      />

      <h2>Code:</h2>
      <pre class="code-block"><code>
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// Define a struct for product details
struct Product {
    string name;
    string category;
    double price;

    Product(string n, string c, double p) : name(n), category(c), price(p) {}
};

// AVL tree node for product management
class Node {
public:
    Product data;
    Node* left;
    Node* right;
    int height;

    Node(Product d) : data(d), left(nullptr), right(nullptr), height(1) {}
};

int height(Node* N) {
    if (N == nullptr) return 0;
    return N-&gt;height;
}

int max(int a, int b) {
    return (a &gt; b) ? a : b;
}

Node* rightRotate(Node* y) {
    Node* x = y-&gt;left;
    Node* T2 = x-&gt;right;

    x-&gt;right = y;
    y-&gt;left = T2;

    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + 1;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x-&gt;right;
    Node* T2 = y-&gt;left;

    y-&gt;left = x;
    x-&gt;right = T2;

    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + 1;

    return y;
}

int getBalance(Node* N) {
    if (N == nullptr) return 0;
    return height(N-&gt;left) - height(N-&gt;right);
}

Node* insert(Node* node, Product data) {
    if (node == nullptr) return new Node(data);

    if (data.name &lt; node-&gt;data.name)
        node-&gt;left = insert(node-&gt;left, data);
    else if (data.name &gt; node-&gt;data.name)
        node-&gt;right = insert(node-&gt;right, data);
    else
        return node;

    node-&gt;height = 1 + max(height(node-&gt;left), height(node-&gt;right));

    int balance = getBalance(node);

    if (balance &gt; 1 &amp;&amp; data.name &lt; node-&gt;left-&gt;data.name)
        return rightRotate(node);

    if (balance &lt; -1 &amp;&amp; data.name &gt; node-&gt;right-&gt;data.name)
        return leftRotate(node);

    if (balance &gt; 1 &amp;&amp; data.name &gt; node-&gt;left-&gt;data.name) {
        node-&gt;left = leftRotate(node-&gt;left);
        return rightRotate(node);
    }

    if (balance &lt; -1 &amp;&amp; data.name &lt; node-&gt;right-&gt;data.name) {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    return node;
}

void inorder(Node* root) {
    if (root != nullptr) {
        inorder(root-&gt;left);
        cout &lt;&lt; &quot;Name: &quot; &lt;&lt; root-&gt;data.name &lt;&lt; &quot;, Category: &quot; &lt;&lt; root-&gt;data.category
             &lt;&lt; &quot;, Price: $&quot; &lt;&lt; root-&gt;data.price &lt;&lt; endl;
        inorder(root-&gt;right);
    }
}

int main() {
    Node* root = nullptr;

    root = insert(root, Product(&quot;Laptop&quot;, &quot;Electronics&quot;, 999.99));
    root = insert(root, Product(&quot;Headphones&quot;, &quot;Electronics&quot;, 199.99));
    root = insert(root, Product(&quot;Coffee Maker&quot;, &quot;Home Appliances&quot;, 49.99));
    root = insert(root, Product(&quot;Sneakers&quot;, &quot;Footwear&quot;, 79.99));
    root = insert(root, Product(&quot;Smartphone&quot;, &quot;Electronics&quot;, 699.99));

    cout &lt;&lt; &quot;Products in sorted order:&quot; &lt;&lt; endl;
    inorder(root);

    return 0;
}
  </code></pre>

      <div class="complexity-card">
        <h3 class="card-title">Time Complexity</h3>
        <table class="complexity-table">
          <thead>
            <tr>
              <th>Function</th>
              <th>Amortized</th>
              <th>Worst case</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Search</td>
              <td>O(log n)</td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td>Insert</td>
              <td>O(log n)</td>
              <td>O(log n)</td>
            </tr>
            <tr>
              <td>Delete</td>
              <td>O(log n)</td>
              <td>O(log n)</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="complexity-card">
        <h3 class="card-title">Space Complexity</h3>
        <table class="complexity-table">
          <tr>
            <td>Space</td>
            <td>O(n)</td>
          </tr>
        </table>
      </div>

      <div class="references">
        <h3 class="reference-title">References</h3>
        <ul class="reference-list">
          <li>
            <a
              href="https://en.wikipedia.org/wiki/AVL_tree"
              target="_blank"
              class="reference-link"
              >https://en.wikipedia.org/wiki/AVL_tree</a
            >
          </li>
          <li>
            <a
              href="https://www.geeksforgeeks.org/introduction-to-avl-tree/"
              target="_blank"
              class="reference-link"
              >https://www.geeksforgeeks.org/introduction-to-avl-tree/</a
            >
          </li>
        </ul>
      </div>

      <div class="case-study-navigation">
        <a href="case-6.html" class="nav-link">← Previous Case Study</a>
        <a href="case-8.html" class="nav-link">Next Case Study →</a>
      </div>
    </section>
  </body>
</html>
